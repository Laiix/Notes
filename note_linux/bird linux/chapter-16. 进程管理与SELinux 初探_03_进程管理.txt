1、为什么进程管理这么重要：
	1-在操作系统时的各项工作其实都是经过某个PID 来达成的(包括bash 环境)， 因此，能不能进行某项工作，就与该进程的权限有关了。
	2-如果Linux 系统是个很忙碌的系统，那么当整个系统资源快要被使用光时， 需要能够找出最耗系统的那个进程，然后删除该进程，让系统恢复正常
	3-由于某个程序写的不好，导致产生一个有问题的进程在内存当中，需要找出他，然后将他移除
	4-如果同时有五六项工作在系统当中运作，但其中有一项工作才是最重要的，如何让那一项重要的工作被最优先执行
2、进程的观察
	利用静态的 ps或者是动态的top，还能以pstree 可以查阅进程树之间的关系
	1-ps(process status) ：将某个时间点的进程运作情况撷取下来
		$ ps aux <==观察系统所有的进程数据
		$ ps -lA <==也是能够观察所有系统的数据
		$ ps axjf <==连同部分进程树状态
			选项与参数：
			-e ：所有的 process 均显示出来，与 -A 具有同样的效用；
			-A ：所有的 process 均显示出来，与 -e 具有同样的效用；
			-a ：不与 terminal 有关的所有 process ；
			-u ：有效使用者 (effective user) 相关的 process ；
			x ：通常与 a 这个参数一起使用，可列出较完整信息。
			输出格式规划：
			l ：较长、较详细的将该 PID 的的信息列出；
			j ：工作的格式 (jobs format)
			-f ：做一个更为完整的输出。
		ps 这个指令的man page 不是很好查阅，因为很多不同的Unix 都使用这个ps 来查阅进程状态， 为了要符合不同版本的需求，所以这个 man page 写的非常的庞大！因此，直接背两个比较不同的选项， 一个是只能查阅自己bash进程的『ps -l 』一个则是可以查阅所有系统运作的进程『ps aux 』！注意，是『ps aux 』没有那个减号(-) ！先来看看关于自己bash 进程状态的观察：
			1）仅观察自己的bash 相关进程： ps -l（注意，只输入ps显示只与自己的 bash 有关的进程）
				范例一：将目前属于您自己这次登入的 PID 与相关信息列示出来(只与自己的 bash 有关)
					$ ps -l
						F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
						0 S  1000 27472 27471  0  80   0 - 28881 do_wai pts/2    00:00:00 bash
						0 R  1000 31114 27472  0  80   0 - 37235 -      pts/2    00:00:00 ps
						# 非必要不要使用 root 直接登入吧？从这个 ps -l 的分析，你也可以发现，
						# 其实是使用 sudo 才转成 root 的身份～否则连测试机，都是使用一般账号登入的！
					系统整体的进程运作是非常多的，但如果使用ps -l 则仅列出与你的操作环境(bash) 有关的进程而已， 亦即最上层的父进程会是你自己的 bash 而没有延伸到systemd (后续会交待！) 这支进程去！那么ps -l 展示资料有哪些呢？ 我们就来观察看看：
						F：
							代表这个进程旗标(process flags)，说明这个进程的总结权限，常见号码有：
								若为4 表示此进程的权限为root ；
 								若为1 则表示此子进程仅进行复制(fork)而没有实际执行(exec)。
 						S：
							代表这个进程的状态(STAT)，主要的状态有：
								R (Running)：该程序正在运作中；
								S (Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。
								D ：不可被唤醒的睡眠状态，通常这支程序可能在等待I/O 的情况(ex>打印)
								T ：停止状态(stop)，可能是在工作控制(背景暂停)或除错(traced) 状态；
								Z (Zombie)：僵尸状态，进程已经终止但却无法被移除至内存外。
						UID/PID/PPID：
							代表『此进程被该UID 所拥有/进程的PID 号码/此进程的父进程PID 号码』
						C：
							代表CPU 使用率，单位为百分比；
						PRI/NI：
							Priority/Nice 的缩写，代表此进程被CPU 所执行的优先级，数值越小代表该进程越快被CPU 执行。
							详细的PRI 与NI 将在下一小节说明。
						ADDR/SZ/WCHAN：
							都与内存有关，ADDR 是kernel function，指出该进程在内存的哪个部分，如果是个running 的进程，一般就会显示『- 』 / SZ 代表此进程用掉多少内存/ WCHAN 表示目前进程是否运作中，同样的， 若为 - 表示正在运作中。
						TTY：
							登入者的终端机位置，若为远程登录则使用动态终端接口(pts/n)；
						TIME：
							使用掉的CPU 时间，注意，是此进程实际花费CPU 运作的时间，而不是系统时间；
						CMD：
							就是command 的缩写，造成此进程的触发程序之指令为何。
					所以你看到的 ps -l 输出讯息中，他说明的是：『bash 的程序属于UID 为1000 的使用者，状态为睡眠(sleep)， 之所以为睡眠因为他触发了ps (状态为run) 之故。此进程的PID 为14836，优先执行顺序为80 ， 下达 bash 所取得的终端接口为pts/2 ，运作状态为等待(o_wai) 。』
			2）观察系统所有进程： ps aux
				范例二：列出目前所有的正在内存当中的进程：
					$ ps aux | head -n 5
						USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
						root         1  0.0  0.0 125228  2152 ?        Ss   Aug22   2:02 /usr/lib/systemd/systemd --system --deserialize 20
						root         2  0.0  0.0      0     0 ?        S    Aug22   0:00 [kthreadd]
						root         3  0.0  0.0      0     0 ?        S    Aug22   0:23 [ksoftirqd/0]
						root         5  0.0  0.0      0     0 ?        S<   Aug22   0:00 [kworker/0:0H]
					ps -l 与ps aux 显示的项目并不相同！在ps aux 显示的项目中，各字段的意义为：
						USER：该 process 属于那个使用者账号的？
						PID ：该 process 的进程标识符。
						%CPU：该 process 使用掉的 CPU 资源百分比；
						%MEM：该 process 所占用的物理内存百分比；
						VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)
						RSS ：该 process 占用的固定的内存量 (Kbytes)
						TTY ：该 process 是在那个终端机上面运作，若与终端机无关则显示 ?，另外， tty1-tty6 是本机上面的登入者进程，若为 pts/0 等等的，则表示为由网络连接进主机的进程。
						STAT：该进程目前的状态，状态显示与 ps -l 的 S 旗标相同 (R/S/T/Z)
						START：该 process 被触发启动的时间；
						TIME ：该 process 实际使用 CPU 运作的时间。
						COMMAND：该进程的实际指令为何？
					一般来说，ps aux 会依照PID 的顺序来排序显示
					请注意"ps -aux"不同于"ps aux"。POSIX和UNIX的标准要求"ps -aux"打印用户名为"x"的用户的所有进程，以及打印所有将由-a选项选择的过程。如果用户名为"x"不存在，ps的将会解释为"ps aux"，而且会打印一个警告。这种行为是为了帮助转换旧脚本和习惯。它是脆弱的，即将更改，因此不应依赖。 
					如果你运行ps -aux >/dev/null，那么你就会得到下面这行警告信息 :
						Warning: bad ps syntax, perhaps a bogus '-'? See http://procps.sf.net/faq.html 
					综上： 使用时两者之间直接选择ps aux
					ps aux 和ps -ef 两者的输出结果差别不大，但展示风格不同。aux是BSD风格，-ef是System V风格。
				范例三：以范例一的显示内容，显示出所有的进程：
					$ ps -lA
						....(以下省略)....
						# 你会发现每个字段与 ps -l 的输出情况相同，但显示的进程则包括系统所有的进程。
				范例四：列出类似进程树的进程显示：
					$ ps axjf
				范例五：找出与 cron 与 rsyslog 这两个服务有关的 PID
					$ ps aux | egrep '(cron|rsyslog)'
				除此之外，我们必须要知道的是『僵尸(zombie) 』进程是什么？ 通常，造成僵尸进程的成因是因为该进程应该已经执行完毕，或者是因故应该要终止了， 但是该进程的父进程却无法完整的将该进程结束掉，而造成那个进程一直存在内存当中。如果你发现在某个进程的 CMD 后面还接上<defunct> 时，就代表该进程是僵尸进程啦，例如：
					apache 8683 0.0 0.9 83384 9992 ? Z 14:33 0:00 /usr/sbin/httpd <defunct>
				当系统不稳定的时候就容易造成所谓的僵尸进程，可能是因为程序写的不好，或者是使用者的操作习惯不良等等所造成。如果你发现系统中很多僵尸进程时，记得啊！要找出该进程的父进程，然后好好的做个追踪，好好的进行主机的环境优化！ 看看有什么地方需要改善的，不要只是直接将他kill 掉而已呢！不然的话，万一他一直产生，那可就麻烦了！事实上，通常僵尸进程都已经无法控管，而直接是交给systemd这支程序来负责了，偏偏systemd是系统第一支执行的程序， 他是所有程序的父程序！我们无法杀掉该程序的 (杀掉他，系统就死掉！)，所以，如果产生僵尸进程，而系统过一阵子还没有办法透过核心非经常性的特殊处理来将该进程删除时，只好透过reboot 的方式来将该进程抹去！
	2-top：动态观察进程的变化
		相对于 ps 是撷取一个时间点的进程状态， top 则可以持续侦测进程运作的状态！使用方式如下：
		$ top [-d 数字] | top [-bnp]
			选项与参数：
			-d ：后面可以接秒数，就是整个进程画面更新的秒数。预设是 5 秒；
			-b ：以批次的方式执行 top ，还有更多的参数可以使用！
				通常会搭配数据流重导向来将批次的结果输出成为文件。
			-n ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。
			-p ：指定某些个 PID 来进行观察监测而已。
			在 top 执行过程当中可以使用的按键指令：
				? ：显示在 top 当中可以输入的按键指令；
				P ：以 CPU 的使用资源排序显示；
				M ：以 Memory 的使用资源排序显示；
				N ：以 PID 来排序喔！
				T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序。
				k ：给予某个 PID 一个讯号 (signal)
				r ：给予某个 PID 重新制订一个 nice 值。
				q ：离开 top 软件的按键。
			eg：
				范例一：每两秒钟更新一次 top ，观察整体信息：
					$ top -d 2
						top - 00:53:59 up 6:07, 3 users, load average: 0.00, 0.01, 0.05
						Tasks: 179 total, 2 running, 177 sleeping, 0 stopped, 0 zombie
						%Cpu(s): 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
						KiB Mem : 2916388 total, 1839140 free, 353712 used, 723536 buff/cache
						KiB Swap: 1048572 total, 1048572 free, 0 used. 2318680 avail Mem
						<==如果加入 k 或 r 时，就会有相关的字样出现在这里喔！
						PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
						18804 root 20 0 130028 1872 1276 R 0.5 0.1 0:00.02 top
						1 root 20 0 60636 7948 2656 S 0.0 0.3 0:01.70 systemd
						2 root 20 0 0 0 0 S 0.0 0.0 0:00.01 kthreadd
						3 root 20 0 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/0
					top 这个程序可以持续的监测整个系统的进程工作状态。在预设的情况下，每次更新进程资源的时间为5 秒，不过，可以使用-d来进行修改。top 主要分为两个画面，上面的画面为整个系统的资源使用状态，基本上总共有六行，显示的内容依序是：
						第一行(top...)：这一行显示的信息分别为：
							o 目前的时间，亦即是00:53:59 那个项目；
							o 开机到目前为止所经过的时间，亦即是up 6:07, 那个项目；
							o 已经登入系统的用户人数，亦即是3 users, 项目；
							o 系统在1, 5, 15 分钟的平均工作负载。我们在第十五章谈到的batch 工作方式为负载小于0.8 就是这个负载！代表的是1, 5, 15 分钟，系统平均要负责运作几个进程(工作)的意思。越小代表系统越闲置，若高于1 得要注意你的系统进程是否太过繁复了！
						第二行(Tasks...)：显示的是目前进程的总量与个别进程在什么状态(running, sleeping, stopped, zombie)。比较需要注意的是最后的zombie 那个数值，如果不是0 ！好好看看到底是那个process 变成僵尸了
						第三行(%Cpus...)：显示的是CPU 的整体负载，每个项目可使用? 查阅。需要特别注意的是wa 项目，那个项目代表的是I/O wait， 通常你的系统会变慢都是I/O 产生的问题比较大！因此这里得要注意这个项目耗用CPU 的资源喔！ 另外，如果是多核心的设备，可以按下数字键『1』来切换成不同CPU 的负载率。
						第四行与第五行：表示目前的物理内存与虚拟内存(Mem/Swap) 的使用情况。再次重申，要注意的是swap的使用量要尽量的少！如果swap 被用的很大量，表示系统的物理内存实在不足！
						第六行：这个是当在top 程序当中输入指令时，显示状态的地方。
					至于 top 下半部分的画面，则是每个process 使用的资源情况。比较需要注意的是：
						PID ：每个 process 的 ID ！
						USER：该 process 所属的使用者；
						PR ：Priority 的简写，进程的优先执行顺序，越小越早被执行；
						NI ：Nice 的简写，与 Priority 有关，也是越小越早被执行；
						%CPU：CPU 的使用率；
						%MEM：内存的使用率；
						TIME+：CPU 使用时间的累加；
				范例二：将 top 的信息进行 2 次，然后将结果输出到 /tmp/top.txt
					$ top -b -n 2 > /tmp/top.txt
				范例三：我们自己的 bash PID 可由 $$ 变量取得，请使用 top 持续观察该 PID
					$ echo $$
						14836 <==就是这个数字！他是我们 bash 的 PID
					$ top -d 2 -p 14836
				范例四：承上题，上面的 NI 值是 0 ，想要改成 10 的话？
					# 在范例三的 top 画面当中直接按下 r 之后，会出现如下的图样！
						top - 01:02:01 up 6:15, 3 users, load average: 0.00, 0.01, 0.05
						Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie
						%Cpu(s): 0.1 us, 0.0 sy, 0.0 ni, 99.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
						KiB Mem : 2916388 total, 1839140 free, 353576 used, 723672 buff/cache
						KiB Swap: 1048572 total, 1048572 free, 0 used. 2318724 avail Mem
						PID to renice [default pid = 14836] 14836
						PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
						14836 root 20 0 116272 3136 1848 S 0.0 0.1 0:00.07 bash
					在你完成上面的动作后，在状态栏会出现如下的信息：
						Renice PID 14836 to value 10 <==这是 nice 值
						PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
					接下来你就会看到如下的显示画面！
						top - 01:04:13 up 6:17, 3 users, load average: 0.00, 0.01, 0.05
						Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie
						%Cpu(s): 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
						KiB Mem : 2916388 total, 1838676 free, 354020 used, 723692 buff/cache
						KiB Swap: 1048572 total, 1048572 free, 0 used. 2318256 avail Mem
						PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
						14836 root 30 10 116272 3136 1848 S 0.0 0.1 0:00.07 bash
	3-pstree
		$ pstree [-A|U] [-up]
			选项与参数：
			-A ：各进程树之间的连接以 ASCII 字符来连接；
			-U ：各进程树之间的连接以万国码的字符来连接。在某些终端接口下可能会有错误；
			-p ：并同时列出每个 process 的 PID；
			-u ：并同时列出每个 process 的所属账号名称。
			eg:
				范例一：列出目前系统上面所有的进程树的相关性：
					$ pstree -A
				范例二：承上题，PID 与 users
					$ pstree -Aup
					# 在括号 () 内的即是 PID 以及该进程的 owner 喔！一般来说，如果该进程的所有人与父进程同，
					# 就不会列出，但是如果与父进程不一样，那就会列出该进程的拥有者！
				一般链接符号可以使用 ASCII 码即可，但有时因为语系问题会主动的以Unicode 的符号来链接， 但因为可能终端机无法支持该编码，或许会造成乱码问题。因此可以加上-A 选项来克服此类线段乱码问题。
3、进程的管理
	进程之间是可以互相控制的！举例来说，你可以关闭、重新启动服务器软件，服务器软件本身是个进程， 你既然可以让她关闭或启动，当然就是可以控制该进程啦！那么进程是如何互相管理的呢？其实是透过给予该进程一个讯号(signal) 去告知该进程你想要让她作什么！因此这个讯号就很重要啦！
	可以使用 kill -l (小写的L )或者是man 7 signal 都可以查询到！主要的讯号代号与名称对应及内容是：
		1 		SIGHUP 		启动被终止的进程，可让该 PID 重新读取自己的配置文件，类似重新启动，以及关闭shell
		2 		SIGINT 		相当于用键盘输入 [ctrl]-c 来中断一个进程的进行
		9 		SIGKILL		代表强制中断一个进程的进行，如果该进程进行到一半， 那么尚未完成的部分可能会有『半产品』产生，类似 vim 会有 .filename.swp 保留下来。
		15 		SIGTERM		以正常的结束进程来终止该进程。由于是正常的终止， 所以后续的动作会将他完成。不过，如果该进程已经发生问题，就是无法使用正常的方法终止时， 输入这个 signal 也是没有用的。
		19 		SIGSTOP 	相当于用键盘输入 [ctrl]-z 来暂停一个进程的进行
	一般来说，你只要记得『1, 9, 15』这三个号码的意义即可。那么我们如何传送一个讯号给某个进程呢？就透过kill 或killall 吧！
	1-kill -signal PID
		kill 可以帮我们将这个signal 传送给某个工作(%jobnumber) 或者是某个PID (直接输入数字)。要再次强调的是：kill 后面直接加数字与加上%number 的情况是不同的！ 这个很重要喔！因为工作控制中有1 号工作，但是PID 1 号则是专指『systemd 』这支程序！将systemd 关闭 systemd ，你的系统就当掉！所以记得那个% 是专门用在工作控制！ 
	2-killall -signal 指令名称
		由于 kill 后面必须要加上PID (或者是job number)，所以，通常kill 都会配合ps, pstree 等指令，因为我们必须要找到相对应的那个进程的ID ！但是，如此一来，很麻烦～有没有可以利用『下达指令的名称』来给予讯号的？举例来说，能不能直接将rsyslogd 这个进程给予一个SIGHUP 的讯号呢？用killall！
		$ killall [-iIe] [command name]
			选项与参数：
			-i ：interactive 的意思，交互式的，若需要删除时，会出现提示字符给用户；
			-e ：exact 的意思，表示『后面接的 command name 要一致』，但整个完整的指令不能超过 15 个字符。
			-I ：指令名称(可能含参数)忽略大小写。
			eg：
				范例一：给予 rsyslogd 这个指令启动的 PID 一个 SIGHUP 的讯号
					$ killall -1 rsyslogd
						# 如果用 ps aux 仔细看一下，若包含所有参数，则 /usr/sbin/rsyslogd -n 才是最完整的！
				范例二：强制终止所有以 httpd 启动的进程 (其实并没有此进程在系统内)
					$ killall -9 httpd
				范例三：依次询问每个 bash 程序是否需要被终止运作！
					$ killall -i -9 bash
					Signal bash(13888) ? (y/N) n <==这个不杀！
					Signal bash(13928) ? (y/N) n <==这个不杀！
					Signal bash(13970) ? (y/N) n <==这个不杀！
					Signal bash(14836) ? (y/N) y <==这个杀掉！
					# 具有互动的功能！可以询问你是否要删除 bash 这个程序。要注意，若没有 -i 的参数，
					# 所有的 bash 都会被这个 root 给杀掉！包括 root 自己的 bash
4、关于进程的执行顺序
	我们知道 Linux 是多人多任务的环境，由top 的输出结果我们也发现， 系统同时间有非常多的进程在运行中，只是绝大部分的进程都在休眠(sleeping) 状态而已。想一想，如果所有的进程同时被唤醒，那么CPU 应该要先处理那个进程呢？也就是说，那个进程被执行的优先序比较高？ 这就得要考虑到进程的优先执行序(Priority) 与CPU 排程啰！	CPU 排程与前一章的例行性工作排程并不一样。CPU 排程指的是每支进程被CPU运作的演算规则， 而例行性工作排程则是将某支程序安排在某个时间再交由系统执行。CPU 排程与操作系统较具有相关性！
	1-Priority 与Nice 值
		