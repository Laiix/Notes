1、为什么进程管理这么重要：
	1-在操作系统时的各项工作其实都是经过某个PID 来达成的(包括bash 环境)， 因此，能不能进行某项工作，就与该进程的权限有关了。
	2-如果Linux 系统是个很忙碌的系统，那么当整个系统资源快要被使用光时， 需要能够找出最耗系统的那个进程，然后删除该进程，让系统恢复正常
	3-由于某个程序写的不好，导致产生一个有问题的进程在内存当中，需要找出他，然后将他移除
	4-如果同时有五六项工作在系统当中运作，但其中有一项工作才是最重要的，如何让那一项重要的工作被最优先执行
2、进程的观察
	利用静态的 ps或者是动态的top，还能以pstree 可以查阅进程树之间的关系
	1-ps ：将某个时间点的进程运作情况撷取下来
		$ ps aux <==观察系统所有的进程数据
		$ ps -lA <==也是能够观察所有系统的数据
		$ ps axjf <==连同部分进程树状态
			选项与参数：
			-e ：所有的 process 均显示出来，与 -A 具有同样的效用；
			-A ：所有的 process 均显示出来，与 -e 具有同样的效用；
			-a ：不与 terminal 有关的所有 process ；
			-u ：有效使用者 (effective user) 相关的 process ；
			x ：通常与 a 这个参数一起使用，可列出较完整信息。
			输出格式规划：
			l ：较长、较详细的将该 PID 的的信息列出；
			j ：工作的格式 (jobs format)
			-f ：做一个更为完整的输出。
		ps 这个指令的man page 不是很好查阅，因为很多不同的Unix 都使用这个ps 来查阅进程状态， 为了要符合不同版本的需求，所以这个 man page 写的非常的庞大！因此，直接背两个比较不同的选项， 一个是只能查阅自己bash进程的『ps -l 』一个则是可以查阅所有系统运作的进程『ps aux 』！注意，是『ps aux 』没有那个减号(-) ！先来看看关于自己bash 进程状态的观察：
			1）仅观察自己的bash 相关进程： ps -l（注意，只输入ps显示只与自己的 bash 有关的进程）
				范例一：将目前属于您自己这次登入的 PID 与相关信息列示出来(只与自己的 bash 有关)
					$ ps -l
						F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
						0 S  1000 27472 27471  0  80   0 - 28881 do_wai pts/2    00:00:00 bash
						0 R  1000 31114 27472  0  80   0 - 37235 -      pts/2    00:00:00 ps
						# 非必要不要使用 root 直接登入吧？从这个 ps -l 的分析，你也可以发现，
						# 其实是使用 sudo 才转成 root 的身份～否则连测试机，都是使用一般账号登入的！
					系统整体的进程运作是非常多的，但如果使用ps -l 则仅列出与你的操作环境(bash) 有关的进程而已， 亦即最上层的父进程会是你自己的 bash 而没有延伸到systemd (后续会交待！) 这支进程去！那么ps -l 展示资料有哪些呢？ 我们就来观察看看：
						F：
							代表这个进程旗标(process flags)，说明这个进程的总结权限，常见号码有：
								若为4 表示此进程的权限为root ；
 								若为1 则表示此子进程仅进行复制(fork)而没有实际执行(exec)。
 						S：
							代表这个进程的状态(STAT)，主要的状态有：
								R (Running)：该程序正在运作中；
								S (Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。
								D ：不可被唤醒的睡眠状态，通常这支程序可能在等待I/O 的情况(ex>打印)
								T ：停止状态(stop)，可能是在工作控制(背景暂停)或除错(traced) 状态；
								Z (Zombie)：僵尸状态，进程已经终止但却无法被移除至内存外。
						UID/PID/PPID：
							代表『此进程被该UID 所拥有/进程的PID 号码/此进程的父进程PID 号码』
						C：
							代表CPU 使用率，单位为百分比；
						PRI/NI：
							Priority/Nice 的缩写，代表此进程被CPU 所执行的优先级，数值越小代表该进程越快被CPU 执行。
							详细的PRI 与NI 将在下一小节说明。
						ADDR/SZ/WCHAN：
							都与内存有关，ADDR 是kernel function，指出该进程在内存的哪个部分，如果是个running 的进程，一般就会显示『- 』 / SZ 代表此进程用掉多少内存/ WCHAN 表示目前进程是否运作中，同样的， 若为 - 表示正在运作中。
						TTY：
							登入者的终端机位置，若为远程登录则使用动态终端接口(pts/n)；
						TIME：
							使用掉的CPU 时间，注意，是此进程实际花费CPU 运作的时间，而不是系统时间；
						CMD：
							就是command 的缩写，造成此进程的触发程序之指令为何。
					所以你看到的 ps -l 输出讯息中，他说明的是：『bash 的程序属于UID 为1000 的使用者，状态为睡眠(sleep)， 之所以为睡眠因为他触发了ps (状态为run) 之故。此进程的PID 为14836，优先执行顺序为80 ， 下达 bash 所取得的终端接口为pts/2 ，运作状态为等待(o_wai) 。』
			2）观察系统所有进程： ps aux
				范例二：列出目前所有的正在内存当中的进程：
					$ ps aux | head -n 5
						USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
						root         1  0.0  0.0 125228  2152 ?        Ss   Aug22   2:02 /usr/lib/systemd/systemd --system --deserialize 20
						root         2  0.0  0.0      0     0 ?        S    Aug22   0:00 [kthreadd]
						root         3  0.0  0.0      0     0 ?        S    Aug22   0:23 [ksoftirqd/0]
						root         5  0.0  0.0      0     0 ?        S<   Aug22   0:00 [kworker/0:0H]
					ps -l 与ps aux 显示的项目并不相同！在ps aux 显示的项目中，各字段的意义为：
						USER：该 process 属于那个使用者账号的？
						PID ：该 process 的进程标识符。
						%CPU：该 process 使用掉的 CPU 资源百分比；
						%MEM：该 process 所占用的物理内存百分比；
						VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)
						RSS ：该 process 占用的固定的内存量 (Kbytes)
						TTY ：该 process 是在那个终端机上面运作，若与终端机无关则显示 ?，另外， tty1-tty6 是本机上面的登入者进程，若为 pts/0 等等的，则表示为由网络连接进主机的进程。
						STAT：该进程目前的状态，状态显示与 ps -l 的 S 旗标相同 (R/S/T/Z)
						START：该 process 被触发启动的时间；
						TIME ：该 process 实际使用 CPU 运作的时间。
						COMMAND：该进程的实际指令为何？
					一般来说，ps aux 会依照PID 的顺序来排序显示
					
				