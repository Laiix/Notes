1、systemd使用的unit分类
	从CentOS 7.x以后，Red Hat系列的distribution放弃沿用多年的System V开机启动服务的流程，即前面提到的init启动脚本的方法，改用systemd这个启动服务管理机制。
	1-平行处理所有服务，加速开机流程：
		旧的 init 启动脚本是『一项一项任务依序启动』的模式，因此不相依的服务也是得要一个一个的等待。但目前我们的硬件主机系统与操作系统几乎都支持多核心架构了， 没道理未相依的服务不能同时启动！systemd 就是可以让所有的服务同时启动，系统启动的速度变快！
	2-一经要求就响应的on-demand 启动方式：
		systemd全部就是仅有一只systemd服务搭配systemctl指令来处理，无须其他额外的指令来支持。不像systemV 还要init, chkconfig, service... 等等指令。此外， systemd 由于常驻内存，因此任何要求(on-demand)都可以立即处理后续的daemon启动的任务。
	3-服务相依性的自我检查：
		由于systemd可以自定义服务相依性的检查，因此如果B服务是架构在A服务上面启动的，在没有启动A服务的情况下仅手动启动B服务时，systemd会自动启动A服务！这样就可以免去管理员得要一项一项服务去分析的麻烦
	4-依daemon功能分类：
		systemd旗下管理的服务非常多，为了厘清所有服务的功能，因此，首先systemd 先定义所有的服务为一个服务单位(unit)，并将该unit归类到不同的服务类型(type) 去。旧的init仅分为stand alone 与super daemon，systemd 将服务单位(unit) 区分为service, socket, target, path, snapshot,timer 等多种不同的类型(type)，方便管理员的分类与记忆。
	5-将多个daemons集合成为一个群组：
		如同systemV的init 头有个runlevel的特色，systemd 亦将许多的功能集合成为一个所谓的target项目，这个项目主要在设计操作环境的建置，所以是集合了许多的daemons，即执行某个target 就是执行多个daemon！
	6-向下兼容旧有的init 服务脚本：
		基本上，systemd 是可以兼容于init的启动脚本的，因此，旧的init启动脚本也能够透过systemd来管理，只是更进阶的systemd功能就没有办法支持了。
	虽然如此，不过 systemd 也是有些地方无法完全取代init的！包括：
	1-在runlevel的对应上，大概仅有runlevel 1, 3, 5有对应到systemd的某些target类型而已，没有全部对应；
	2-全部的systemd都用systemctl这个管理程序管理，而systemctl 支持的语法有限制，不像/etc/init.d/daemon就是纯脚本可以自定义参数，systemctl不可自定义参数。；
	3-如果某个服务启动是管理员自己手动执行启动，而不是使用systemctl去启动的(例如你自己手动输入crond 以启动crond 服务)，那么systemd 将无法侦测到该服务，而无法进一步管理。
	4-systemd 启动过程中，无法与管理员透过standard input 传入讯息！因此，自行撰写systemd 的启动设定时，务必要取消互动机制～(连透过启动时传进的标准输入讯息也要避免！)
2、systemd的配置文件放置目录
	基本上，systemd 将过去所谓的daemon执行脚本通通称为一个服务单位(unit)，而每种服务单位依据功能来区分时，就分类为不同的类型(type)。基本的类型有包括系统服务、数据监听与交换的插槽档服务(socket)、储存系统状态的快照类型、提供不同类似执行等级分类的操作环境(target) 等等。这么多类型不会很麻烦，因为配置文件都放置在底下的目录中：
	1-/usr/lib/systemd/system/：每个服务最主要的启动脚本设定，有点类似以前的/etc/init.d 底下的文件；
	2-/run/systemd/system/：系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/ 高！
	3-/etc/systemd/system/：管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx 之类的功能！执行优先序又比/run/systemd/system/高
	也就是说，到底系统开机会不会执行某些服务其实是看 /etc/systemd/system/ 底下的设定，所以该目录底下就是一大堆连结档。而实际执行的systemd 启动脚本配置文件， 其实都是放置在/usr/lib/systemd/system/ 底下！因此如果你想要修改某个服务启动的设定，应该要去/usr/lib/systemd/system/ 底下修改！/etc/systemd/system/ 仅是连结到正确的执行脚本配置文件而已。所以想要看执行脚本设定，应该就得要到/usr/lib/systemd/system/ 底下去查阅！
3、systemd的unit类型分类说明
	/usr/lib/systemd/system/下根据扩展名的类型， 我们大概可以找到几种比较常见的systemd的服务类型如下：
	.service
		一般服务类型 (service unit)：主要是系统服务，包括服务器本身所需要的本地服务以及网络服务都是！比较经常被使用到的服务大多是这种类型！所以，这也是最常见的类型了！
	.socket
		内部程序数据交换的插槽服务(socket unit)：主要是 IPC (Inter-process communication) 的传输讯息插槽文件 (socket file) 功能。 这种类型的服务通常在监控讯息传递的插槽文件，当有透过此插槽文件传递讯息来说要链接服务时，就依据当时的状态将该用户的要求传送到对应的daemon，若daemon尚未启动，则启动该daemon后再传送用户的要求。使用socket类型的服务一般是比较不会被用到的服务，因此在开机时通常会稍微延迟启动的时间。一般用于本地服务比较多，例如我们的图形界面很多的软件都是透过socket来进行本机程序数据交换的行为。(这与早期的xinetd 这个super daemon有部份的相似！)
	.target
		执行环境类型 (target unit)：其实是一群unit 的集合，例如上面表格中谈到的 multi-user.target 其实就是一堆服务的集合，也就是说，选择执行multi-user.target就是执行一堆其他.service 、 .socket 之类的服务！
	.mount
	.automount
		文件系统挂载相关的服务 (automount unit / mount unit)：例如来自网络的自动挂载、NFS 文件系统挂载等与文件系统相关性较高的程序管理。
	.path
		侦测特定文件或目录类型 (path unit)：某些服务需要侦测某些特定的目录来提供队列服务，例如最常见的打印服务，就是透过侦测打印队列目录来启动打印功能！ 这时就得要 .path 的服务类型支持了！
	.timer
		循环执行的服务 (timer unit)：这个东西有点类似anacrontab！不过是由systemd主动提供的，比anacrontab更加有弹性！
4、透过systemctl 管理服务
	1-透过systemctl管理单一服务(service unit)的启动/开机启动与观察状态
		一般来说，服务的启动有两个阶段，一个是『开机的时候设定要不要启动这个服务』， 以及『现在要不要启动这个服务』
		$ systemctl [command] [unit]
			command 主要有：
			start ：立刻启动后面接的unit
			stop ：立刻关闭后面接的unit
			restart ：立刻关闭后启动后面接的unit，亦即执行stop再start的意思
			reload ：不关闭后面接的unit 的情况下，重载配置文件，让设定生效
			enable ：设定下次开机时，后面接的 unit 会被启动
			disable ：设定下次开机时，后面接的 unit 不会被启动
			status ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机预设执行否、登录等信息等！
			is-active ：目前有没有正在运作中
			is-enable ：开机时有没有预设要启用这个 unit
		eg：
			$ systemctl status atd.service
				atd.service - Job spooling tools
				Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled)
				Active: active (running) since Mon 2015-08-10 19:17:09 CST; 5h 42min ago
				Main PID: 1350 (atd)
				CGroup: /system.slice/atd.service
				└─1350 /usr/sbin/atd -f
				Aug 10 19:17:09 xxxxx systemd[1]: Started Job spooling tools.
				# 重点在第二、三行～
				# Loaded：这行在说明，开机的时候这个unit会不会启动，enabled 为开机启动，disabled 开机不会启动
				# Active：现在这个 unit 的状态是正在执行 (running) 或没有执行 (dead)
				# 后面几行则是说明这个 unit 程序的 PID 状态以及最后一行显示这个服务的登录文件信息！
				# 登录文件信息格式为：『时间』 『讯息发送主机』 『哪一个服务的讯息』 『实际讯息内容』
				# 所以上面的显示讯息是：这个 atd 预设开机就启动，而且现在正在运作的意思！
			$ systemctl stop atd.service
				不应该使用kill 的方式来关掉一个正常的服务！否则systemctl会无法继续监控该服务systemtctl status atd 的输出结果中，第2, 3 两行很重要～因为那是该unit 下次开机会不会预设启动，以及目前启动的状态！ 相当重要！最底下unit的登录档～如果unit曾经出错过，观察这个地方也是相当重要的。
	