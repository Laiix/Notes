1、这个工作管理 (job control) 是用在bash 环境下的，也就是说：『当我们登入系统取得bash shell 之后，在单一终端机接口下同时进行多个工作的行为管理』。举例来说，我们在登入bash后， 想要一边复制文件、一边进行资料搜寻、一边进行编译，还可以一边进行vim 程序撰写！ 当然我们可以重复登入那六个文字接口的终端机环境中，不在一个bash达成，就是使用job control
2、什么是工作管理？
	1-进行工作管理的行为中， 其实每个工作都是目前 bash 的子进程，亦即彼此之间是有相关性的。我们无法以 job control 的方式由tty1 的环境去管理tty2 的bash
	2-于假设我们只有一个终端接口，因此在可以出现提示字符让你操作的环境就称为前景(foreground)，至于其他工作就可以让你放入背景(background) 去暂停或运作。要注意的是，放入背景的工作想要运作时， 他必须不能够与使用者互动。举例来说， vim 绝对不可能在背景里面执行(running) 的！因为你没有输入数据他就不会跑啊！ 而且放入背景的工作是不可以使用[ctrl]+c 来终止的！
	3-总之，要进行 bash 的job control 必须要注意到的限制是：
		1）这些工作所触发的进程必须来自于你shell 的子进程(只管理自己的bash)；
		2）前景：你可以控制与下达指令的这个环境称为前景的工作(foreground)；
		3）背景：可以自行运作的工作，你无法使用[ctrl]+c 终止他，可使用bg/fg 呼叫该工作；
		4）背景中『执行』的进程不能等待terminal/shell 的输入(input)
3、job control 的管理
	bash只能够管理自己的工作而不能管理其他bash的工作，所以即使你是root也不能够将别人的bash底下的job给他拿过来执行。此外，又分前景与背景，然后在背景里面的工作状态又可以分为『暂停(stop)』与『运作中(running)』
	1）直接将指令丢到背景中『执行』的&
		eg：
			$ tar -zpcf /tmp/etc.tar.gz /etc &
				[1] 14432 <== [job number] PID
			$ tar: Removing leading `/' from member names
				# 在中括号内的号码为工作号码 (job number)，该号码与 bash 的控制有关。
				# 后续的 14432 则是这个工作在系统中的 PID。至于后续出现的数据是 tar 执行的数据流，
				# 由于我们没有加上数据流重导向，所以会影响画面！不过不会影响前景的操作喔！
		在输入一个指令后，在该指令的最后面加上一个『& 』代表将该指令丢到背景中，此时 bash 会给予这个指令一个『工作号码(job number)』，就是那个[1] 啦！至于后面那个14432 则是该指令所触发的『PID 』了！而且，有趣的是，我们可以继续操作bash！ 不过，丢到背景中的工作什么时候完成？完成的时候会显示什么？如果你输入几个指令后，突然出现这个数据：
			[1]+ Done tar -zpcf /tmp/etc.tar.gz /etc
		就代表[1] 这个工作已经完成(Done) ，该工作的指令则是接在后面那一串指令列。另外，这个& 代表：『将工作丢到背景中去执行』！ 注意到那个『执行』的字眼！此外，这样的情况最大的好处是： 不怕被 [ctrl]+c 中断的啦！ 此外，将工作丢到背景当中要特别注意资料的流向喔！包括上面的讯息就有出现错误讯息，导致我的前景被影响。虽然只要按下 [enter] 就会出现提示字符。但如果我将刚刚那个指令改成：
			$ tar -zpcvf /tmp/etc.tar.gz /etc &
		情况会怎样？在背景当中执行的指令，如果有stdout 及stderr 时，他的数据依旧是输出到屏幕上面的，所以，我们会无法看到提示字符，当然也就无法完好的掌握前景工作。同时由于是背景工作的tar ，此时你怎么按下 [ctrl]+c 也无法停止屏幕被搞的花花绿绿的！所以啰，最佳的状况就是利用数据流重导向， 将输出数据传送至某个文件中。举例来说，我可以这样做：
			$ tar -zpcvf /tmp/etc.tar.gz /etc > /tmp/log.txt 2>&1 &
	2）将『目前』的工作丢到背景中『暂停』：[ctrl]-z
		如果我正在使用 vim ，却发现我有个文件不知道放在哪里，需要到bash 环境下进行搜寻，此时是否要结束vim 呢？呵呵！当然不需要啊！只要暂时将vim 给他丢到背景当中等待即可。例如以下的案例：
			$ vim ~/.bashrc
				# 在 vim 的一般模式下，按下 [ctrl]-z 这两个按键
				[1]+ Stopped vim ~/.bashrc
			$ <==顺利取得了前景的操控权！
			$ find / -print
				....(输出省略)....
				# 此时屏幕会非常的忙碌！因为屏幕上会显示所有的文件名。请按下 [ctrl]-z 暂停
				[2]+ Stopped find / -print
		在vim 的一般模式下，按下[ctrl] 及z 这两个按键，屏幕上会出现[1] ，表示这是第一个工作， 而那个+ 代表最近一个被丢进背景的工作，且目前在背景下预设会被取用的那个工作(与fg这个指令有关)！而那个Stopped 则代表目前这个工作的状态。在预设的情况下，使用[ctrl]-z 丢到背景当中的工作都是『暂停』的状态
	3）观察目前的背景工作状态： jobs
		$ jobs [-lrs]
			选项与参数：
			-l ：除了列出 job number 与指令串之外，同时列出 PID 的号码；
			-r ：仅列出正在背景 run 的工作；
			-s ：仅列出正在背景当中暂停 (stop) 的工作。
		eg：观察目前的 bash 当中，所有的工作，与对应的 PID
			$ jobs -l
				[1]- 14566 Stopped vim ~/.bashrc
				[2]+ 14567 Stopped find / -print
		如果想要知道目前有多少的工作在背景当中，就用jobs 这个指令！一般来说，直接下达jobs 即可！ 不过，如果你还想要知道该job number 的PID 号码，可以加上-l 这个参数啦！ 在输出的信息当中，例如上表，仔细看到那个+ - 号喔！那个+ 代表预设的取用工作。所以说：『目前我有两个工作在背景当中，两个工作都是暂停的， 而如果我仅输入 fg 时，那么那个[2] 会被拿到前景当中来处理』！其实 + 代表最近被放到背景的工作号码， - 代表最近最后第二个被放置到背景中的工作号码。 而超过最后第三个以后的工作，就不会有+/- 符号存在了！
	4）将背景工作拿到前景来处理：fg(foreground)
		$ fg %jobnumber
			选项与参数：
			%jobnumber ：jobnumber 为工作号码(数字)。注意，那个 % 是可有可无的！
		eg：先以 jobs 观察工作，再将工作取出：
			$ jobs -l
				[1]- 14566 Stopped vim ~/.bashrc
				[2]+ 14567 Stopped find / -print
			$ fg <==预设取出那个 + 的工作，亦即 [2]。立即按下[ctrl]-z
			$ fg %1 <==直接规定取出的那个工作号码！再按下[ctrl]-z
			$ jobs -l
				[1]+ 14566 Stopped vim ~/.bashrc
				[2]- 14567 Stopped find / -print
		经过fg 指令就能够将背景工作拿到前景来处理！不过比较有趣的是最后一个显示的结果，我们会发现+ 出现在第一个工作后！ 怎么会这样啊？这是因为你刚刚利用 fg %1 将第一号工作捉到前景后又放回背景，此时最后一个被放入背景的将变成vi 那个指令动作，所以当然 [1] 后面就会出现+了！另外，如果输入『fg - 』 则代表将- 号的那个工作号码拿出来，上面就是 [2]- 那个工作号码！
	5）让工作在背景下的状态变成运作中： bg
		eg:
			$ find / -perm /7000 > /tmp/text.txt
				# 此时，请立刻按下 [ctrl]-z 暂停！
				[3]+ Stopped find / -perm /7000 > /tmp/text.txt
			$ jobs ; bg %3 ; jobs
				[1] Stopped vim ~/.bashrc
				[2]- Stopped find / -print
				[3]+ Stopped find / -perm /7000 > /tmp/text.txt
				[3]+ find / -perm /7000 > /tmp/text.txt &
				[1]- Stopped vim ~/.bashrc
				[2]+ Stopped find / -print
				[3] Running find / -perm /7000 > /tmp/text.txt &
			由Stopping 变成了Running ！ 指令列最后方多了一个& 的符号啰！ 代表该工作被启动在背景当中
	6）管理背景当中的工作： kill
		刚刚我们可以让一个已经在背景当中的工作继续工作，也可以让该工作以fg拿到前景来，那么，如果想要将该工作直接移除呢？或者是将该工作重新启动呢？这个时候就得需要给予该工作一个讯号(signal)
			$ kill -signal %jobnumber
			$ kill -l
				选项与参数：
				-l ：这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些？
				signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知：
					-1 ：重新读取一次参数的配置文件 (类似 reload)；
					-2 ：代表与由键盘输入 [ctrl]-c 同样的动作；
					-9 ：立刻强制删除一个工作；
					-15：以正常的进程方式终止一项工作。与 -9 是不一样的。
		eg:
		找出目前的 bash 环境下的背景工作，并将该工作『强制删除』。
			$ jobs
				[1]+ Stopped vim ~/.bashrc
				[2] Stopped find / -print
			$ kill -9 %2; jobs
				[1]+ Stopped vim ~/.bashrc
				[2] Killed find / -print
				# 再过几秒你再下达 jobs 一次，就会发现 2 号工作不见了！因为被移除了！
		找出目前的 bash 环境下的背景工作，并将该工作『正常终止』掉。
			$ jobs
				[1]+ Stopped vim ~/.bashrc
			$ kill -SIGTERM %1
				# -SIGTERM 与 -15 是一样的！您可以使用 kill -l 来查阅！
				# 不过在这个案例中， vim 的工作无法被结束喔！因为他无法透过 kill 正常终止的意思！
		1-特别留意一下， -9 这个signal 通常是用在『强制删除一个不正常的工作』时所使用的， -15 则是以正常步骤结束一项工作(15 也是默认值)，两者之间并不相同呦！举上面的例子来说， 我用 vim 的时候，不是会产生一个.filename.swp 的文件吗？ 那么，当使用 -15 这个signal 时， vim 会尝试以正常的步骤来结束掉该vi 的工作， 所以 .filename.swp 会主动的被移除。但若是使用-9 这个signal 时，由于该vim 工作会被强制移除掉，因此， .filename.swp 就会继续存在文件系统当中。
		2-不过，毕竟正常的作法中，你应该先使用 fg 来取回前景控制权，然后再离开vim 才对～因此，以上面的范例为例，其实kill 确实无法使用-15 正常的结束掉vim 的动作喔！此时还是不建议使用-9 啦！因为你知道如何正常结束该进程不是吗？ 通常使用 -9 是因为某些程序你真的不知道怎么透过正常手段去终止他，这才用到-9 的！
		3-其实，kill 的妙用是很无穷的啦！他搭配signal 所详列的信息(用man 7 signal 去查阅相关资料) 可以让您有效的管理工作与进程(Process)，此外，那个killall 也是同样的用法！ 至于常用的 signal 您至少需要了解1, 9, 15 这三个signal 的意义才好。此外， signal 除了以数值来表示之外，也可以使用讯号名称喔！ 举例来说，上面的范例就是一个例子啦！至于signal number 与名称的对应，使用kill -l 就知道啦(L 的小写)！
		4-kill 后面接的数字默认会是PID ，如果想要管理bash 的工作控制，就得要加上%数字了，这点也得特别留意才行
4、脱机管理问题
	要注意的是，我们在工作管理当中提到的『背景』指的是在终端机模式下可以避免[crtl]-c中断的一个情境，你可以说那个是bash的背景，并不是放到系统的背景去喔！所以，工作管理的背景依旧与终端机有关啦！在这样的情况下，如果你是以远程联机方式连接到你的Linux主机，并且将工作以&的方式放到背景去，请问，在工作尚未结束的情况下你脱机了，该工作还会继续进行吗？答案是『否』！不会继续进行，而是会被中断掉。
	如果我的工作需要进行一大段时间，我又不能放置在背景底下，那该如何处理呢？ 首先，你可以参考前一章的at 来处理即可！因为 at 是将工作放置到系统背景， 而与终端机无关。如果不想要使用at 的话，那你也可以尝试使用nohup 这个指令来处理喔！这个nohup 可以让你在脱机或注销系统后，还能够让工作继续进行。他的语法有点像这样：
		$ nohup [指令与参数] <==在终端机前景中工作
		$ nohup [指令与参数] & <==在终端机背景中工作
		# 上述指令需要注意的是， nohup 并不支持bash 内建的指令，因此你的指令必须要是外部指令才行
	eg：
		#1. 先编辑一支会『睡着 500 秒』的程序：
			$ vim sleep500.sh
				#!/bin/bash
				/bin/sleep 500s
				/bin/echo "I have slept 500 seconds."
		# 2. 丢到背景中去执行，并且立刻注销系统：
			$ chmod a+x sleep500.sh
			$ nohup ./sleep500.sh &
				[2] 14812
			$ nohup: ignoring input and appending output to `nohup.out' <==会告知这个讯息！
			$ exit
	如果你再次登入的话，再使用pstree 去查阅你的进程，会发现sleep500.sh 还在执行中喔！并不会被中断掉！由于我们的程序最后会输出一个讯息，但是nohup 与终端机其实无关了， 因此这个讯息的输出就会被导向『~/nohup.out 』，所以你才会看到上述指令中，当你输入nohup后， 会出现那个提示讯息啰。
	如果你想要让在背景的工作在你注销后还能够继续的执行，那么使用 nohup 搭配& 是不错的运作情境喔！
5、nohup和&理解
	1-&的意思是在后台运行，当你在执行 cmd & 的时候， 即使你用ctrl C,  那么cmd照样运行（因为对SIGINT信号免疫）。 但是要注意，如果你直接关掉shell后，那么，cmd进程同样消失。 可见， &的后台并不硬（因为对SIGHUP信号不免疫）。
	2-nohup的意思是忽略SIGHUP信号， 所以当运行nohup cmd的时候， 关闭shell, 那么a.out进程还是存在的（对SIGHUP信号免疫）。但是，要注意，如果你直接在shell中用Ctrl C,那么,cmd进程也是会消失的（因为对SIGINT信号不免疫）
	3-让进程真正不受shell中Ctrl C和shell关闭的影响，用nohup cmd &吧，两全其美。